<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=0.8"><title>Preface</title><link rel="stylesheet" type="text/css" href="part_preface_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="part_preface_files/shared.css" title="default"><link rel="stylesheet" type="text/css" href="part_preface_files/figure.css" title="default"><link rel="stylesheet" type="text/css" href="part_preface_files/racket.css" title="default"><link rel="stylesheet" type="text/css" href="part_preface_files/manual-style.css" title="default"><link rel="stylesheet" type="text/css" href="part_preface_files/manual-racket.css" title="default"><script type="text/javascript" src="part_preface_files/scribble-common.js"></script><script type="text/javascript" src="part_preface_files/figure.js"></script><script type="text/javascript" src="part_preface_files/manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick='TocviewToggle(this,"tocview_0");'>▼</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">How to Design Programs, Second Edition</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue:<span class="mywbr"> &nbsp;</span> How to Program</a></td></tr><tr><td align="right">I&nbsp;</td><td><a href="part_one.html" class="tocviewlink" data-pltdoc="x">Fixed Size Data</a></td></tr><tr><td align="right"></td><td><a href="i1-2.html" class="tocviewlink" data-pltdoc="x">Intermezzo 1: Beginning Student Language</a></td></tr><tr><td align="right">II&nbsp;</td><td><a href="part_two.html" class="tocviewlink" data-pltdoc="x">Arbitrarily Large Data</a></td></tr><tr><td align="right"></td><td><a href="i2-3.html" class="tocviewlink" data-pltdoc="x">Intermezzo 2: Quote, Unquote</a></td></tr><tr><td align="right">III&nbsp;</td><td><a href="part_three.html" class="tocviewlink" data-pltdoc="x">Abstraction</a></td></tr><tr><td align="right"></td><td><a href="i3-4.html" class="tocviewlink" data-pltdoc="x">Intermezzo 3: Scope and Abstraction</a></td></tr><tr><td align="right">IV&nbsp;</td><td><a href="part_four.html" class="tocviewlink" data-pltdoc="x">Intertwined Data</a></td></tr><tr><td align="right"></td><td><a href="i4-5.html" class="tocviewlink" data-pltdoc="x">Intermezzo 4: The Nature of Numbers</a></td></tr><tr><td align="right">V&nbsp;</td><td><a href="part_five.html" class="tocviewlink" data-pltdoc="x">Generative Recursion</a></td></tr><tr><td align="right"></td><td><a href="i5-6.html" class="tocviewlink" data-pltdoc="x">Intermezzo 5: The Cost of Computation</a></td></tr><tr><td align="right">VI&nbsp;</td><td><a href="part_six.html" class="tocviewlink" data-pltdoc="x">Accumulators</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue:<span class="mywbr"> &nbsp;</span> Moving On</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick='TocviewToggle(this,"tocview_1");'>►</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Preface</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="#%28part._.Acknowledgments_from_the_.First_.Edition%29" class="tocviewlink" data-pltdoc="x">Acknowledgments from the First Edition</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Acknowledgments%29" class="tocviewlink" data-pltdoc="x">Acknowledgments</a></td></tr></tbody></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.0.0.10</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="part_prologue.html" title="forward to &quot;Prologue: How to Program&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h3><a name="(part._part~3apreface)"></a>Preface</h3><a name="(part._chap~3apart~3apreface)"></a><table cellspacing="0" cellpadding="0"><tbody><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3asystematic-design%29" class="toclink" data-pltdoc="x">Систематическая разработка программы</a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._drtl%29" class="toclink" data-pltdoc="x">DrRacket и языки обучения</a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._skills%29" class="toclink" data-pltdoc="x">Передаваемые навыки</a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._this%29" class="toclink" data-pltdoc="x">Эта книга и ее части </a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._delta%29" class="toclink" data-pltdoc="x">Различия</a></p>

</td></tr></tbody></table>

<p>Многие профессии требуют некоторой формы программирования. Бухгалтера программируют
таблицы; музыканты программируют синтезаторы; авторы программируют текстовые процессоры; 
и веб-дизайнеры программируют таблицы стилей. Когда мы писали эти слова для 
первого издания книги (1995–2000), читатели, возможно, сочли их футуристическими; 
К настоящему времени программирование стало обязательным навыком, и многочисленные источники
- книги, онлайн-курсы, учебные программы K-12 - удовлетворяют эту потребность, всегда с целью
улучшения  перспектив трудоустройства людей. </p>

<p>Типичный курс программирования учит подходу “возиться, пока не заработает“. 
Когда это работает, студенты восклицают: “Работает!“ и идем дальше. К сожалению, 
эта фраза также является кратчайшей ложью в вычислительной технике и стоила многим 
людям многих часов их жизни. Напротив, эта книга фокусируется на навыках <span class="emph">хорошего программирования</span>, адресована как специалистам, так и профессиональным программистам.</p>

<p>Под “хорошим программированием“ мы подразумеваем подход к созданию 
программного обеспечения, основанный на систематическом мышлении, планировании 
и понимании с самого начала, на каждом этапе и на каждом шаге. Чтобы подчеркнуть 
этот момент, мы говорим о систематической разработке программ и систематически 
разработанных программах. Что особенно важно, последнее формулирует обоснование 
желаемой функциональности. Хорошее программирование также удовлетворяет эстетическое 
чувство выполненного долга; Элегантность хорошей программы сравнима с проверенными 
временем стихами или черно-белыми фотографиями ушедшей эпохи. Короче говоря, 
программирование отличается от хорошего программирования, как наброски карандашом 
в закусочной от картины маслом в музее. </p>

<p></p>

<div class="SIntrapara">Нет, эта книга никого не превратит в мастера живописи. Но мы не потратили бы пятнадцать лет на написание этого издания, если бы не верили, что
</div><div class="SIntrapara"><blockquote class="SCentered">

<p><span class="emph"> каждый может разрабатывать программы</span></p>

</blockquote></div><div class="SIntrapara">и
</div><div class="SIntrapara"><blockquote class="SCentered">

<p><span class="emph">каждый может испытать удовлетворение от креативной разработки.</span></p>

</blockquote></div><div class="SIntrapara">Действительно, мы идем еще дальше и утверждаем, что
</div><div class="SIntrapara"><blockquote class="SCentered">

<p><span class="emph">разработка программ, но <span style="font-weight: bold">не прграммирование</span>— заслуживает той же роли 

в гуманитарном образовании, что и математика и языковые навыки.</span></p>

</blockquote></div><div class="SIntrapara">Студент, изучающий разраотку, который 
никогда больше не коснется программирования, по-прежнему приобретет универсально 
полезные навыки решения проблем, испытает глубокую творческую деятельность и научится 
ценить новую форму эстетики. Остальная часть этого предисловия подробно объясняет, 
что мы имеем в виду под "систематической разработкой", кому и чем это выгодно, и как 
мы обучаем всему этому.</div>

<p></p>

<h4><a name="(part._sec~3asystematic-design)"></a>Systematic Program Design</h4>

<p>Программа взаимодействует с людьми, называемыми <span style="font-style: italic">
пользователями</span> и другими программами, и в этом случае мы говорим о 
<span style="font-style: italic">серверных</span> и <span style="font-style: italic">
клиентских</span> компонентах. Следовательно, любая достаточно полная программа 
состоит из множества строительных блоков: некоторые имеют дело с вводом, 
некоторые создают вывод, а некоторые ликвидируют разрыв между этими двумя. 
Мы предпочитаем использовать функции в качестве фундаментальных строительных блоков, 
потому что каждый сталкивается с функциями в пре-алгебре и потому, что простейшие 
программы являются именно такими функциями. Главное - выяснить, какие функции необходимы, 
как их соединить и как построить их из базовых ингредиентов. .</p>

<p>В этом контексте “систематическая разработка программы“ означает сочетание 
двух концепций: рецептов разработки и итеративного уточнения.
<span class="refelem"><span class="refcolumn"><span class="refcontent">
Мы черпали вдохновение в методе Майкла Джексона для создания программ на языке COBOL, 
а также в беседах с Дэниелом Фридманом о рекурсии, Робертом Харпером о теории типов и 
Дэниелом Джексоном о разработке программного обеспечения.
</span></span></span>
Рецепты разработки - открытие авторов, и здесь они их активно используют.</p>

<blockquote class="Figure"><a name="(counter._(figure._fig~3athe-design-recipe))" x-target-lift="Figure"></a><blockquote class="Leftfigure"><blockquote class="FigureInside"><ol><li>

<p><span style="font-weight: bold">От анализа проблем к определению данных </span></p>

<p><span class="Smaller">Определите, какая информация должна быть представлена 
и как она представлена на выбранном языке программирования. Сформулируйте 
определения данных и проиллюстрируйте их примерами. </span></p>

</li><li>

<p><span style="font-weight: bold">Сигнатура, Предназначение(Формулировка Цели), Заголовок</span></p>

<p><span class="Smaller">Укажите, какие данные использует и производит желаемая функция. 
Сформулируйте краткий ответ на вопрос, <span class="emph">что</span> вычисляет функция. 
Определите заглушку, соответствующую сигнатуре.</span></p>

</li><li>

<p><span style="font-weight: bold">Функциональные примеры</span></p>

<p><span class="Smaller">Проработайте примеры, иллюстрирующие назначение(цели) функции.</span></p>

</li><li>

<p><span style="font-weight: bold">Шаблон Функции</span></p>

<p><span class="Smaller">Переведите определения данных в план(набросок) функции. </span></p>

</li><li>

<p><span style="font-weight: bold">Определение функции</span></p>

<p><span class="Smaller">Заполните пробелы в шаблоне функции. Используйте предназначение 
и примеры. </span></p>

</li><li>

<p><span style="font-weight: bold">Тестирование</span></p>

<p><span class="Smaller">Сформулируйте примеры как тесты и убедитесь, что функция 
проходит все тесты. Так вы обнаружите ошибки. Тесты также дополняют примеры в 
том смысле, что они помогают другим прочитать и понять определение, когда в этом 
возникнет необходимость - а она возникнет для любой серьезной программы. </span></p>

</li></ol></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget">Рисунок&nbsp;1: </span>Основные шаги рецепта разработки функции
</span></p>

</blockquote>

<p><span style="font-weight: bold">Рецепты разработки</span> применимы как к 
законченным программам, так и к отдельным функциям. В этой книге есть всего 
два рецепта для законченных программ: один для программ с графическим пользовательским 
интерфейсом (GUI) и один для пакетных программ. Напротив, рецепты проектирования 
функций бывают самых разных видов: для атомарных форм данных, таких как числа; 
для перечисления разного рода данных; для данных, которые фиксированным образом 
объединяют другие данные; для конечных, но произвольно больших данных; и так далее. </p>

<p>Рецепты разработки на функциональном уровне имеют общий <span style="font-weight: bold">
процесс разработки(проектирования)</span>. На  <a href="#%28counter._%28figure._fig~3athe-design-recipe%29%29" data-pltdoc="x">рисунке&nbsp;<span class="FigureRef">1</span></a>
 показаны шесть его основных шагов. Название каждого шага указывает ожидаемый результат(ы); 
"команды" предлагают ключевые действия. Примеры играют центральную роль почти на каждом этапе.

<span class="refelem"><span class="refcolumn"><span class="refcontent"><span style="font-weight: bold">Преподавателям</span> Попросите учащихся скопировать <a href="#%28counter._%28figure._fig~3athe-design-recipe%29%29" data-pltdoc="x">Рисунок&nbsp;<span class="FigureRef">1</span></a> 
на одной стороне каталожной карточки. Когда ученик застрянет, попросите его предъявить карточку 
и указать ступеньку, на которой он застрял.</span></span></span>

Для выбранного представления данных на шаге 1 запись примеров показывает, 
как реальная информация кодируется как данные и как данные интерпретируются как информация. 
В шаге 3 говорится, что специалист по решению проблем должен проработать конкретные сценарии, 
чтобы понять, что ожидаемая функция будет вычислять для конкретных примеров. 
Это понимание используется на шаге 5, когда пора определять функцию. Наконец, 
шаг 6 требует, чтобы примеры были преобразованы в автоматизированный тестовый код, 
который гарантирует правильную работу функции в некоторых случаях. 
Запуск функции на реальных данных может выявить другие расхождения между ожиданиями и результатами. </p>

<p>На каждом этапе процесса разработки возникают острые вопросы, 
которые задаются в шести частях книги. Для определенных шагов - например, 
создания функциональных примеров или шаблона - вопросы могут относиться к 
определению данных. Ответы почти автоматически создают промежуточный продукт.
<span class="refelem"><span class="refcolumn"><span class="refcontent"><span style="font-weight: bold">
Преподаватели.</span> Наиболее важные вопросы относятся к шагам 4 и 5. Попросите студентов записать эти вопросы своими словами на обратной стороне их индексных  их карточек.
</span></span></span>

Эти строительные леса окупаются, когда приходит время сделать один творческий 
шаг в процессе: завершить определение функции. И даже тогда доступна помощь 
практически во всех случаях. </p>

<p>Новизна этого подхода - создание промежуточных продуктов для программ начального уровня. 
Когда новичок застрял, эксперт или инструктор могут проверить существующие промежуточные 
продукты. В ходе инспекции, вероятно, будут использоваться общие вопросы из процесса проектирования, 
что побудит новичка исправить себя. И этот процесс саморазвития - ключевое различие между
программированием и разработкой программ. </p>

<p><span style="font-weight: bold">Итеративное уточнение</span>  решает проблему сложности 
и многогранности проблем. Сделать все сразу сразу практически невозможно. Вместо этого 
компьютерные ученые заимствуют итеративное уточнение у физических наук, чтобы решить 
эту проблему проектирования. По сути, итеративное уточнение рекомендует сначала 
отбросить все несущественные детали и найти решение оставшейся основной проблемы. 
Шаг уточнения добавляет одну из этих пропущенных деталей и повторно решает 
расширенную проблему, максимально используя существующее решение. Повторение, 
также называемое итерацией, этих этапов уточнения в конечном итоге приводит 
к полному решению. </p>

<p>В этом смысле программист - миниатюрный ученый. Ученые создают 
приблизительные модели для какой-то идеализированной версии мира, 
чтобы делать прогнозы относительно него. Пока прогнозы модели сбываются, 
все в порядке; когда предсказанные события отличаются от реальных, 
ученые пересматривают свои модели, чтобы уменьшить расхождение. 
Аналогичным образом, когда программистам дается задача, они создают 
первую разработку, превращают её в код, оценивают её с реальными пользователями 
и итеративно уточняют разработку, пока поведение программы не будет точно 
соответствовать желаемому продукту. </p>

<p>Эта книга представляет итеративное уточнение двумя разными способами. 
Поскольку проектирование посредством уточнения становится полезным даже 
тогда, когда проектирование программ становится сложным, книга подробно 
знакомит с этой техникой в четвертой части, когда проблемы приобретают 
определенную степень сложности. Кроме того, мы используем итеративное 
уточнение, чтобы формулировать все более сложные варианты одной и той 
же проблемы в течение первых трех частей книги. То есть мы выбираем 
основную проблему, рассматриваем ее в одной главе, а затем ставим 
аналогичную проблему в следующей главе - с деталями, соответствующими 
недавно введенным концепциям. </p>

<h4><a name="(part._drtl)"></a>DrRacket и языки обучения</h4>

<p>Чтобы научиться разрабатывать программы, нужно постоянно практиковаться. 
Подобно тому, как никто не становится пианистом, не играя на пианино, 
никто не становится разработчиком программ, не создавая настоящие программы 
и не заставляя их работать должным образом. Следовательно, наша книга поставляется 
с минимальной поддержкой программного обеспечения: языком, на котором можно писать 
программы, и средой разработки программ, с помощью которой программы редактируются 
как текстовые документы и с помощью которой читатели могут запускать программы. 
</p>

<p>Многие люди, с которыми мы сталкиваемся, говорят нам, что хотели бы узнать, 
как кодировать, а затем спрашивают, <span class="emph">какой язык программирования</span>
им следует изучить. 
Учитывая рекламу, которую получают некоторые языки программирования, этот вопрос 
неудивителен. Но это тоже совершенно неуместно.

<span class="refelem"><span class="refcolumn"><span class="refcontent"><span style="font-weight: bold">Инструкторы</span> Для курсов, не предназначенных для начинающих, можно использовать стандартный язык с рецептами разработки.</span></span></span>

Обучение программированию на модном в настоящее время языке программирования часто приводит 
студентов к неудачам. Мода в этом мире очень недолговечна. Типичная книга или курс "Быстрое программирование в X" не может научить принципам, которые переносятся на следующий язык моды. 
Хуже того, сам язык часто отвлекает от приобретения передаваемых навыков на уровне как 
выражения решений, так и исправления ошибок программирования. </p>

<p>Напротив, обучение разработке программ - это прежде всего изучение принципов 
и приобретение передаваемых навыков. Идеальный язык программирования должен 
поддерживать эти две цели, но ни один стандартный промышленный язык не поддерживает этого. 
Ключевой проблемой является то, что новички совершают ошибки еще до того, как овладевают 
языком в значительной степени, однако языки программирования всегда диагностируют эти 
ошибки, как если бы программист уже знал весь язык. В результате диагностические отчеты
(об ошибках) часто ставят в тупик новичков. </p>

<p>Наше решение - начать с нашего собственного индивидуального языка обучения, 
получившего название “язык для начинающих студентов“ или (Beginning Student Language)BSL. 
По сути, этот язык является “иностранным“ языком, который студенты изучают на 
курсах предварительной алгебры. Он включает обозначения для определений функций, 
применения функций и условных выражений. Также выражения могут быть

<span class="refelem"><span class="refcolumn"><span class="refcontent"><span style="font-weight: bold">Преподаватели</span> Вы можете объяснить, что BSL - это предварительная 
алгебра с дополнительными формами данных и множеством предопределенных функций для них.
</span></span></span>
  вложенными. Таким образом, этот язык настолько мал, что диагностика ошибок 
в терминах всего языка по-прежнему доступна читателям, у которых нет ничего, 
кроме предалгебры. </p>

<p>Студент, овладевший принципами структурного проектирования, может затем перейти 
к “промежуточному студенческому языку“(Intermediate Student Language) и другим продвинутым 
диалектам, совместно именуемым <span class="stt">*SL</span>. В книге эти диалекты 
используются для обучения принципам абстракции и общей рекурсии. Мы твердо уверены, 
что использование такой серии языков обучения дает читателям превосходную подготовку 
к созданию программ для широкого спектра профессиональных языков программирования 
(JavaScript, Python, Ruby, Java и других). </p>

<p><span style="font-weight: bold"> Примечание.</span> Языки обучения реализованы в 
<span style="font-style: italic">Racket</span>, языке программирования, который мы 
создали для создания языков программирования. Racket ускользнул из лаборатории в 
реальный мир, и это средство программирования, которое выбирают в самых разных условиях, 
от игр до управления массивами телескопов. Хотя языки обучения заимствуют элементы из языка Racket, 
эта книга <span style="font-weight: bold">не</span> учит Racket. Опять же, студент, 
который изучил эту книгу, может легко перейти к Racket.   
<span style="font-weight: bold">Конец</span></p>

<p>Когда дело доходит до среды программирования, мы сталкиваемся с таким же 
плохим выбором, как и при выборе языков. Среда программирования для профессионалов
аналогична кабине гигантского реактивного самолета. Она имеет множество элементов 
управления и дисплеев, которые непостижимы для любого, кто впервые запускает такое 
программное приложение. Начинающим программистам нужен эквивалент двухместного 
одномоторного винтового самолета, с которым они могут практиковать базовые навыки. 
Поэтому мы создали DrRacket, среду программирования для новичков. </p>

<p>DrRacket поддерживает очень увлекательное, ориентированное на обратную связь 
обучение с помощью всего двух простых интерактивных панелей: области определений, 
которая содержит определения функций, и области взаимодействий, которая позволяет 
программисту запрашивать оценку(вычисление) выражений, которые могут относиться к 
определениям. В этом контексте исследовать сценарии “что, если“ так же легко, как 
и в приложении для работы с электронными таблицами. Экспериментирование можно начать 
при первом контакте, используя обычные примеры в стиле калькулятора и быстро переходя 
к вычислениям с изображениями, словами и другими формами данных. </p>

<p>Интерактивная среда разработки программ, такая как DrRacket, упрощает процесс 
обучения двумя способами. Во-первых, она позволяет начинающим программистам 
напрямую манипулировать данными. Поскольку никаких средств для чтения входной 
информации из файлов или устройств не требуется, новичкам не нужно тратить 
драгоценное время на выяснение того, как они работают. Во-вторых, такая организация 
строго отделяет данные и манипуляции с ними от ввода и вывода информации из “реального мира“. 
В настоящее время это разделение считается настолько фундаментальным для 
систематического проектирования программного обеспечения, 
что оно носит собственное название: <span style="font-style: italic">архитектура 
модель-представление(вид)-контроллер(MVC)</span>. 
Работая в DrRacket, новые программисты с самого начала естественным образом знакомятся 
с этой фундаментальной идеей программной инженерии. </p>

<h4><a name="(part._skills)"></a>Передаваемые навыки</h4>

<p>Приобретенные в процессе обучения навыки разработки программ систематически 
передаются по двум направлениям. Естественно, они применимы как к программированию в целом, 
так и к программированию электронных таблиц, синтезаторов, таблиц стилей и даже 
текстовых процессоров. Наши наблюдения показывают, что процесс проектирования из рисунка 1 
переносится практически на любой язык программирования и работает как для программ из 10 строк, 
так и для программ из 10 000 строк. Требуется некоторое размышление, чтобы адаптировать процесс
проектирования ко всему спектру языков и масштабам проблем программирования; но как только 
процесс становится второй натурой, его использование окупается во многих отношениях. 
</p>

<p>Учиться разрабатывать программы также означает приобретать два вида универсально 
полезных навыков. Разработка программ, безусловно, учит тем же аналитическим навыкам, 
что и математика, особенно (до) алгебре и геометрии. Но, в отличие от математики, 
работа с программами - это активный подход к обучению. Создание программного обеспечения 
обеспечивает немедленную обратную связь и, таким образом, ведет к исследованиям, 
экспериментам и самооценке. Результатом, как правило, являются интерактивные продукты, 
подход, который значительно увеличивает чувство выполненного долга по сравнению с 
упражнениями в учебниках. </p>

<p>Помимо улучшения математических навыков учащегося, разработка программ учит 
аналитическим навыкам чтения и письма. Даже самые маленькие  задачи разработки
 формулируются в виде текстовых задач. Без прочных навыков чтения и понимания 
невозможно создавать программы, которые решают достаточно сложные задачи. И наоборот, 
методы разработки программ заставляют создателя излагать свои мысли правильным и 
точным языком. Действительно, если студенты действительно усваивают рецепт разработки, 
они улучшают свои навыки артикуляции больше, чем что-либо еще. </p>

<p></p>

<div class="SIntrapara">Чтобы проиллюстрировать этот момент, еще раз взгляните на описание процесса на <a href="#%28counter._%28figure._fig~3athe-design-recipe%29%29" data-pltdoc="x">рисунке&nbsp;<span class="FigureRef"> 1</span></a>. В нем говорится, что разработчик должен 
</div><div class="SIntrapara"><ol><li>

<p>проанализировать постановку проблемы, обычно формулируемую в виде слова - проблема(задача/problem); </p>

</li><li>

<p>извлечь и выразить её суть, абстрактно; </p>

</li><li>

<p>проиллюстрировать суть примерами;</p>

</li><li>

<p>составить наброски и планы на основе этого анализа; </p>

</li><li>

<p>оценинить результаты относительно ожидаемых результатов; и </p>

</li><li>

<p>пересмотреть продукт(результат) в свете неудавшихся проверок и тестов.</p>

</li></ol></div>

<p></p>

<p>Каждый шаг требует анализа, точности, описания, сосредоточенности и внимания к деталям. 
Любой опытный предприниматель, инженер, журналист, юрист, ученый или любой другой профессионал 
может объяснить, сколько из этих навыков необходимо для его повседневной работы. 
Практика разработки программ - на бумаге и в DrRacket - это приятный способ приобрести 
эти навыки.</p>

<p>Точно так же очистка процесса разработки не ограничивается
информатикой и созданием программ. Этим занимаются и архитекторы, композиторы, 
писатели и другие профессионалы. Они начинают с идей в голове и каким-то образом 
формулируют их суть. Они уточняют эти идеи на бумаге, пока их продукт не будет 
в максимальной степени отражать их мысленный образ. Когда они воплощают свои 
идеи на бумаге, они используют навыки, аналогичные полностью усвоенным рецептам 
разработки: рисование, письмо или игра на фортепиано, чтобы выразить определенные 
элементы стиля здания, описать характер человека или сформулировать части мелодии. 
Что делает их продуктивными в итеративном процессе разработки, так это то, что они 
усвоили свои основные рецепты проектирования и научились выбирать, какой из них 
использовать в текущей ситуации. </p>

<h4><a name="(part._this)"></a>Эта книга и ее части </h4>

<p>Цель этой книги - познакомить читателей без предварительного опыта с 
<span class="emph">систематическим проектированием(разработкой) программ</span>. 
В тандеме она представляет собой <span class="emph">символическое представление вычислений</span>, 
метод, объясняющий, как работает применение программы к данным. Грубо говоря, этот метод обобщает то, 
что учащиеся изучают по арифметике в начальной школе и по алгебре в средней школе. Но не бойтесь. 
DrRacket поставляется с механизмом - алгебраическим пошаговым исполнителем - который может 
иллюстрировать эти пошаговые вычисления. </p>

<p>Книга состоит из шести частей, разделенных пятью интермеццо, и дополнена 
Прологом и Эпилогом. В то время как основные части сосредоточены на разработке программ, 
промежуточные части(интермецо) вводят дополнительные концепции, касающиеся механизмов 
программирования и вычислений. </p>

<p></p>

<div class="SIntrapara"><a href="part_prologue.html" data-pltdoc="x">Пролог: Как программировать</a>  
- это краткое введение в простое программирование. В нем объясняется, как написать простую анимацию 
в <span class="stt">*SL</span>. Закончив, любой новичок обязательно почувствует себя одновременно
воодушевленным и подавленным. Таким образом, последнее примечание объясняет, почему простое
программирование неверно и как систематический, постепенный(пошаговый) подход к разработке программ
устраняет чувство страха, которое обычно испытывает каждый начинающий программист. 
Теперь все готово для основы книги: 
</div><div class="SIntrapara"><ul><li>

<p><a href="part_one.html" data-pltdoc="x">Данные фиксированного размера</a>  
объясняет наиболее фундаментальные концепции систематического проектирования на простых примерах.
Основная идея заключается в том, что разработчики обычно имеют приблизительное представление 
о том, какие данные программа должна потреблять(использовать) и производить(возвращать).
Системный подход к проектированию, следовательно, должен извлекать как можно больше подсказок 
из описания данных, которые поступают в программу и исходят из нее. Чтобы упростить задачу, 
эта часть начинается с атомарных данных - чисел, изображений и т.д. - а затем постепенно 
вводятся новые способы описания данных: интервалы, перечисления, детализация, 
структуры и их комбинации. </p>

</li><li>

<p><a href="i1-2.html" data-pltdoc="x">Интермеццо 1: Язык для начинающих учеников</a>  
описывает язык обучения во всех деталях: его словарный запас, его грамматику и его значения. 
Ученые-компьютерщики называют это синтаксисом и семантикой. Разработчики программ используют 
эту модель вычислений для прогнозирования вычислений при запуске или для анализа диагностики 
ошибок. </p>

</li><li>

<p><a href="part_two.html" data-pltdoc="x">Произвольно большие данные(Arbitrarily Large Data)</a>
расширяет <a href="part_one.html" data-pltdoc="x">Данные фиксированного размера</a> средствами 
для описания наиболее интересных и полезных форм данных: произвольно больших составных данных. 
Хотя программист может вкладывать типы данных из раздела <a href="part_one.html" data-pltdoc="x">Fixed-Size Data(Данные Фиксированного Размера)</a> для представления
информации, вложенность всегда имеет фиксированную глубину и ширину. В этой части показано, 
как тонкое обобщение приводит нас к данным произвольного размера. Затем основное внимание 
уделяется систематическому проектированию программ, обрабатывающих такие данные. </p>

</li><li>

<p><a href="i2-3.html" data-pltdoc="x">Intermezzo 2: Quote(цитирование), Unquote(отмена цитирования)</a>
 вводит краткую и мощную нотацию для записи больших фрагментов данных: цитаты и отмену цитаты. </p>

</li><li>

<p><a href="part_three.html" data-pltdoc="x">Абстрагирование(Abstraction)</a>  признает, 
что многие функции из <a href="part_two.html" data-pltdoc="x">Произвольно больших данных</a> похожи. 
Ни один язык программирования не должен заставлять программистов создавать фрагменты кода, 
которые так похожи друг на друга. И наоборот, в каждом хорошем языке программирования есть 
способы устранить такое сходство. Ученые-информатики называют этап устранения сходства и 
его результат абстрагированием, и они знают, что абстракции значительно повышают продуктивность
программиста. Следовательно, в этой части представлены рецепты проектирования для создания и 
использования абстракций. </p>

</li><li>

<p><a href="i3-4.html" data-pltdoc="x">Интермеццо 3: Область Видимости(действия) и Абстракция</a>  играет две роли. 
С одной стороны, оно вводит концепцию <span class="emph">lexical scope(лексической области видимости/действия)
</span>, идею о том, что язык программирования связывает каждое вхождение имени с определением, 
которое программист может найти при просмотре кода. С другой стороны, оно объясняет библиотеку с дополнительными механизмами абстракции, включая так называемые <span class="emph">циклы for</span>.</p>

</li><li>

<p><a href="part_four.html" data-pltdoc="x">Intertwined Data(Переплетенные Данные)</a> обобщает <a href="part_two.html" data-pltdoc="x">Произвольно большие Данные</a> и явно вводит идею итеративного уточнения в каталог концепций разработки.</p>

</li><li>

<p><a href="i4-5.html" data-pltdoc="x">Интермеццо 4: Природа чисел</a> объясняет и иллюстрирует, почему десятичные числа работают таким странным образом во всех языках программирования. Эти основные факты должен знать каждый начинающий программист.</p>

</li><li>

<p><a href="part_five.html" data-pltdoc="x">Генеративная(Порождающая) рекурсия</a> добавляет новый 
принцип разработки. Хотя структурного проектирования и абстракции достаточно для решения 
большинства проблем, с которыми сталкиваются программисты, они иногда приводят к недостаточно
"производительным" программам. То есть программам со структурной разработкой(разработанных на основе структур) может потребоваться 
слишком много времени или энергии для вычисления желаемых ответов. Поэтому специалисты 
по информатике заменяют структурно разработанные программы программами, которые получают 
выгоду из-за специального понимания предметной области. В этой части книги показано, 
как разработать большой класс именно таких программ. 
</p>

</li><li>

<p><a href="i5-6.html" data-pltdoc="x">Интермеццо 5: Стоимость(Цена) вычислений</a> использует 
примеры из <a href="part_five.html" data-pltdoc="x">Генеративная Рекурсия</a>, чтобы 
проиллюстрировать, как компьютерные ученые думают о производительности. </p>

</li><li>

<p><a href="part_six.html" data-pltdoc="x">Аккумуляторы</a> добавляет последний трюк 
в набор инструментов разработчика: аккумуляторы. Грубо говоря, аккумулятор добавляет 
функцию "памяти(memory). Добавление памяти значительно улучшает производительность 
структурно разработанных функций из первых четырех частей книги. Для специальных программ 
из  <a href="part_five.html" data-pltdoc="x">Генеративной Рекурсии(Generative Recursion)</a>
аккумуляторы могут отличать уже найденое значение и состоянием, когда поиск еще не производился. 
</p>

</li></ul></div><div class="SIntrapara"><a href="part_epilogue.html" data-pltdoc="x">Эпилог: "Движение вперед"</a> - это одновременно оценка и взгляд в будущее. </div>

<p></p>

<blockquote class="Figure"><a name="(counter._(figure._fig~3adependence))" x-target-lift="Figure"></a><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCentered">

<p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="part_preface_files/pict.png" alt="image" width="534.0" height="534.0"></p>

</blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget">Рисунок&nbsp;2: </span>Зависимости между частями и интермеццо</span></p>

</blockquote>

<p>Независимые читатели должны проработать всю книгу, от первой до последней страницы. 
Мы говорим "работать", потому что на самом деле имеем в виду, что читатель должен решать 
все упражнения или, по крайней мере, знать, как их решать. </p>

<p>Точно так же инструкторы должны охватить как можно больше элементов, 
начиная с Пролога и заканчивая Эпилогом. Наш опыт преподавания показывает, 
что это выполнимо. Как правило, мы организуем наши курсы таким образом, 
чтобы наши читатели в течение семестра составляли обширную и увлекательную программу. 
Однако мы понимаем, что некоторые обстоятельства требуют значительных сокращений и 
что вкусы некоторых преподавателей требуют несколько иных способов использования книги. </p>

<p><a href="#%28counter._%28figure._fig~3adependence%29%29" data-pltdoc="x">Рисунок&nbsp;<span class="FigureRef">2</span></a>  - это навигационная диаграмма для тех, кто хочет выбирать 
из элементов книги. Рисунок представляет собой график зависимостей. Сплошная стрелка от одного 
элемента к другому предполагает обязательное упорядочение; например, Часть II требует понимания 
Части I. Напротив, пунктирная стрелка в основном является предложением; например, понимание 
Пролога необязательно для прочтения остальной части книги.</p>

<p></p>

<div class="SIntrapara">Основываясь на этой таблице, вот три возможных пути прохождения книги: 
</div><div class="SIntrapara"><ul><li>

<p>Преподаватель средней школы может захотеть охватить (насколько это возможно) 
части I и II, включая небольшой проект, такой как игра. </p>

</li><li>

<p>Преподаватель колледжа в квартальной системе может сосредоточиться на 
<a href="part_one.html" data-pltdoc="x">данных фиксированного размера</a>, 
<a href="part_two.html" data-pltdoc="x">произвольно больших данных</a>, 
<a href="part_three.html" data-pltdoc="x">абстракции</a> и 
<a href="part_five.html" data-pltdoc="x">генеративной рекурсии</a>, 
а также на промежуточных положениях(интермеццо) по <span class="stt">*SL</span> и 
области действия(scope).</p>

</li><li>

<p>Преподаватель колледжа, работающий по семестровой системе, может предпочесть 
как можно раньше обсудить компромиссы производительности в разработке. 
В этом случае лучше всего охватить 
<a href="part_one.html" data-pltdoc="x">данные фиксированного размера</a> и 
<a href="part_two.html" data-pltdoc="x">произвольно большие данные</a>, а затем 
материал по накопителям информации(аккумуляторам) из 
<a href="part_six.html" data-pltdoc="x">аккумуляторы</a>, которая не зависит от 
<a href="part_five.html" data-pltdoc="x">генеративной рекурсии</a>. На этом этапе 
можно обсудить <a href="i5-6.html" data-pltdoc="x">Интермеццо 5: Стоимость вычислений</a>
и изучить остальную часть книги с этой точки зрения. </p>

</li></ul></div>

<p></p>

<p><span style="font-weight: bold">Итерация тем в примерах</span> 
В книге неоднократно возвращаются к определенным упражнениям и типовым темам. 
Например, виртуальные домашние животные встречаются во всех 
<a href="part_one.html" data-pltdoc="x">данных фиксированного размера</a> и даже появляются 
в <a href="part_two.html" data-pltdoc="x">произвольно больших данных</a>. Аналогичным образом, 
как <a href="part_one.html" data-pltdoc="x">данные фиксированного размера</a>, так и 
<a href="part_two.html" data-pltdoc="x">данные произвольно большого размера</a> охватывают 
альтернативные подходы к реализации интерактивного текстового редактора. 
Графы появляются в <a href="part_five.html" data-pltdoc="x">Генеративная Рекурсия</a> и сразу же 
снова в <a href="part_six.html" data-pltdoc="x">Аккумуляторах</a>. Цель этих итераций - 
стимулировать итеративное уточнение и внедрить его исподволь. Мы призываем инструкторов 
назначать эти тематические последовательности упражнений или создавать свои собственные 
такие последовательности. </p>

<h4><a name="(part._delta)"></a>Различия</h4>

<p></p>

<div class="SIntrapara">Второе издание <span style="font-style: italic">Как разрабатывать Программы</span> отличается от первого в нескольких основных аспектах:
</div><div class="SIntrapara"><ol><li>

<p>Она явно признает разницу между проектированием всей программы и функциями, 
составляющими программу. В частности, в этом выпуске основное внимание уделяется 
программам двух типов: программам, управляемым событиями (в основном с графическим 
интерфейсом, но также и сетевым), и пакетным программам. </p>

</li><li>

<p>Разработка программы осуществляется на этапе планирования сверху вниз, 
за которым следует этап строительства снизу вверх. Мы явно показываем, как интерфейс 
к библиотекам определяет форму определенных элементов программы. В частности, самый 
первый этап разработки программы дает список желаемых функций. Хотя концепция списка 
пожеланий существует в первом издании, во втором издании он рассматривается как явный 
элемент разработки. </p>

</li><li>

<p>Выполнение записи из списка желаний зависит от функции
рецепта разработки, которому посвящены шесть основных частей. </p>

</li><li>

<p>Ключевым элементом структурного проектирования является определение функций, 
составляющих другие. Такая разработка через композицию особенно полезна в мире 
пакетных программ. Как и генеративная рекурсия, 
<span class="refelem"><span class="refcolumn"><span class="refcontent">мы благодарим Кэти Фислер за то, что она привлекла наше внимание к этому моменту.</span></span></span>
для этого требуется <span class="emph">эврика!</span>, а именно признание того, 
что создание промежуточных данных одной функцией и обработка этого промежуточного 
результата второй функцией упрощает общую разработку. Для этого подхода также нужен 
список желаний, но формулирование этих желаний требует проницательной разработки 
промежуточного определения данных. Это издание книги включает в себя ряд явных 
упражнений на композиционную разработку. </p>

</li><li>

<p>Хотя тестирование всегда было частью нашей философии разработки, языки обучения 
и DrRacket начали поддерживать его должным образом только в 2002 году, сразу после того, 
как мы выпустили первое издание. Эта новая редакция в значительной степени полагается на 
эту поддержку тестирования </p>

</li><li>

<p>В этом издании книги отсутствует разработка императивных программ. Старые 
главы остаются доступными онлайн. Адаптация этого материала появится во 
втором томе этой серии 
<span style="font-style: italic">Как разрабатывать компоненты.</span></p>

</li><li>

<p>В примерах и упражнениях в книге используются новые обучающие материалы. 
Предпочтительным стилем является связывание этих библиотек с помощью 
<span class="RktSym"><a href="https://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span>, но все же можно добавлять обучающие пакеты 
через меню в DrRacket. </p>

</li><li>

<p></p>

<div class="SIntrapara">Наконец, это второе издание отличается от первого несколькими аспектами терминологии и обозначений: 
</div><div class="SIntrapara"><blockquote><table style="border-collapse: collapse;" cellspacing="0" cellpadding="0"><tbody><tr><td style="border-bottom: 1px solid black;" align="left">

<p>Второе Издание</p>

</td><td style="border-bottom: 1px solid black;" align="left">

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>

</td><td style="border-bottom: 1px solid black;" align="left">

<p>Первое Издание</p>

</td></tr><tr><td align="left">

<p>signature</p>

</td><td align="left">

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>

</td><td align="left">

<p>contract</p>

</td></tr><tr><td align="left">

<p>itemization</p>

</td><td align="left">

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>

</td><td align="left">

<p>union</p>

</td></tr><tr><td align="left">

<p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></p>

</td><td align="left">

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>

</td><td align="left">

<p><span class="RktSym"><a href="https://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._empty%29%29" class="RktValLink" data-pltdoc="x">empty</a></span></p>

</td></tr><tr><td align="left">

<p><span class="RktVal">#true</span></p>

</td><td align="left">

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>

</td><td align="left">

<p><span class="RktSym"><a href="https://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._true%29%29" class="RktValLink" data-pltdoc="x">true</a></span></p>

</td></tr><tr><td align="left">

<p><span class="RktVal">#false</span></p>

</td><td align="left">

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>

</td><td align="left">

<p><span class="RktSym"><a href="https://docs.racket-lang.org/htdp-langs/beginner.html#%28def._%28%28lib._lang%2Fhtdp-beginner..rkt%29._false%29%29" class="RktValLink" data-pltdoc="x">false</a></span></p>

</td></tr></tbody></table></blockquote></div><div class="SIntrapara">Последние три отличия значительно улучшают цитирование списков. </div>

<p></p>

</li></ol></div>

<p></p>

<h3><a name="(part._.Acknowledgments_from_the_.First_.Edition)"></a>Благодарности из первого издания </h3>

<p>Four people deserve special thanks: Robert “Corky” Cartwright, who
co-developed a predecessor of Rice University’s introductory course with the first
author; Daniel P. Friedman, for asking the first author to rewrite
<span class="emph">The Little LISPer</span> (also MIT Press) in 1984, because it started this
project; John Clements, who designed, implemented, and maintains DrRacket’s
stepper; and Paul Steckler, who faithfully supported the team with
contributions to our suite of programming tools.</p>

<p>The development of the book benefited from many other friends and
colleagues who used it in courses and/or gave detailed comments on
early drafts. We are grateful to them for their help and patience:
Ian Barland,
John Clements,
Bruce Duba,
Mike Ernst,
Kathi Fisler,
Daniel P. Friedman,
John Greiner,
Géraldine Morin,
John Stone,
and
Valdemar Tamez.</p>

<p>A dozen generations of Comp 210 students at Rice used
early drafts of the text and contributed improvements in various
ways.  In addition, numerous attendees of our TeachScheme! workshops used early
drafts in their classrooms. Many sent in comments and
suggestions. As representative of these we mention the following active
contributors:
Ms. Barbara Adler,
Dr. Stephen Bloch,
Ms. Karen Buras,
Mr. Jack Clay,
Dr. Richard Clemens,
Mr. Kyle Gillette,
Mr. Marvin Hernandez,
Mr. Michael Hunt,
Ms. Karen North,
Mr. Jamie Raymond,
and
Mr. Robert Reid.
Christopher Felleisen patiently worked through the first few parts of
the book with his father and provided direct insight into the views of a
young student.
Hrvoje Blazevic (sailing, at the time, as Master of the <span style="font-style: italic">LPG/C Harriette</span>),
Joe Zachary (University of
Utah), and Daniel P. Friedman (Indiana University) discovered numerous
typos in the first printing, which we have now fixed.
Thank you to everyone.</p>

<p>Finally, Matthias expresses his gratitude to Helga for her many years of
patience and for creating a home for an absent-minded husband and
father. Robby is grateful to Hsing-Huei Huang for her support and
encouragement; without her, he would not have gotten anything
done. Matthew thanks Wen Yuan for her constant support and enduring music.
Shriram is indebted to Kathi Fisler for support, patience and puns, and for
her participation in this project.</p>

<h3><a name="(part._.Acknowledgments)"></a>Благодарности</h3>

<p>As in 2001, we are grateful to John Clements for designing, validating,
implementing, and maintaining DrRacket’s algebraic stepper. He has done so for
nearly 20 years now, and the stepper has become an indispensable tool of
explanation and instruction.</p>

<p>Over the past few years, several colleagues have commented on the various
drafts and suggested improvements. We gratefully acknowledge the thoughtful
conversations and exchanges with these individuals:</p>

<p></p>

<div class="SIntrapara"><blockquote>

<p>Kathi Fisler (WPI and Brown University), Gregor Kiczales (University of
British Columbia), Prabhakar Ragde (University of Waterloo), and Norman
Ramsey (Tufts University).</p>

</blockquote></div><div class="SIntrapara">Thousands of teachers and instructors attended our various workshops over
the years, and many provided valuable feedback. But Dan Anderson, Stephen
Bloch, Jack Clay, Nadeem Abdul Hamid, and Viera Proulx stand out, and we
wish to call out their role in the crafting of this edition.</div>

<p></p>

<p>Guillaume Marceau, working with Kathi Fisler and Shriram, spent many months
studying and improving the error messages in DrRacket. We are grateful for his
amazing work.</p>

<p>Celeste Hollenbeck is the most amazing reader ever. She never tired of
pushing back until she understood the prose. She never stopped until a
section supported its thesis, its organization matched, and its sentences
connected. Thank you very much for your incredible efforts.</p>

<p>We also thank the following: Ennas Abdussalam,  Mark Aldrich,  Mehmet Akif Akkus,  Anisa Anuar,  Franco Barbeite, 
 Saad Bashir, Aaron Bauman,  Suzanne Becker,  Michael Bausch,  Steven Belknap,
 Stephen Bloch, Elijah Botkin,  Joseph Bogart William Brown, 
 Tomas Cabrera, Xuyuqun C,  Colin Caine,  Anthony Carrico,  Rodolfo Carvalho, 
 Estevo Castro, Maria Chacon, 
 Stephen Chang, David Chatman,  Burleigh Chariton,  Tung Cheng,  Nelson Chiu,  Tomasz Chrzczonowicz, 
 Jack Clay, Richard Cleis,
 John Clements, Scott Crymble,  Pierce Darragh,  Jonas Decraecker,  Qu Dongfang,  Dominique Dijkhuizen, 
 Mark Engelberg, Thomas Evans, Andrew Fallows,  Jiankun Fan,  Christopher Felleisen, Sebastian Felleisen,
 Vladimir Gajić, Xin Gao, 
 Adrian German, Jack Gitelson,  Kyle Gillette,  Jonathan Gordon,  Scott Greene,  Ben Greenman, 
 Ryan Golbeck, Josh Grams,  Grigorios, 
 Jane Griscti, Alberto E. F. Guerrero, Tyler Hammond,  Nan Halberg,  Li Junsong, 
 Nadeem Abdul Hamid, Jeremy Hanlon,  Tony Henk,  Craig Holbrook,  Connor Hetzler,  Benjamin Hosseinzahl, 
 Wayne Iba,
 John Jackaman,  Jordan Johnson, Blake Johnson,  Erwin Junge, 
 Marc Kaufmann, Cole Kendrick, 
 Gregor Kiczales,
 Eugene Kohlbecker, Jaroslaw Kolosowski, Caitlin Kramer,  Roman Kunin, 
 Jackson Lawler, Devon LePage, 
 Ben Lerner, Shicheng Li,  Chen Lj,  Ed Maphis,  YuSheng Mei,  Andres Meza,  Saad Mhmood, 
 Elena Machkasova, Jay Martin, Alexander Martinez,  Yury Mashika, 
 Jay McCarthy, James McDonell,  Mike McHugh,  Wade McReynolds,  David Moses, 
 Ann E. Moskol, Scott Newson, , Štěpán Němec, 
 Paul Ojanen,  Prof. Robert Ordóñez,   Laurent Orseau, 
 Klaus Ostermann,
 Alanna Pasco,  Sinan Pehlivanoglu,  Eric Parker, 
 David Porter, Nick Pleatsikas,  Prathyush Pramod,  Alok Rai, 
 Norman Ramsey,  Krishnan Ravikumar,   Jacob Rubin,  Ilnar Salimzianov,  Luis Sanjuán, 
 Brian Schack,  Ryan “Havvy” Scheel,   Lisa Scheuing,   Willi Schiegel,  Vinit Shah,   Nick Shelley,  Edward Shen, 
 Tubo Shi, Hyeyoung Shin,  Atharva Shukla, Matthew Singer, 
 Michael Siegel, Stephen Siegel, Milton Silva, 
 Kartik Singhal,  Joe Snikeris, 
 Marc Smith, Matthijs Smith, 
 Dave Smylie,
 Vincent St-Amour, Reed Stevens,  William Stevenson,  Kevin Sullivan,  Asumu Takikawa, 
 Éric Tanter,
 Sam Tobin-Hochstadt, Thanos Tsouanas,   Aaron Tsay,  Mariska Twaalfhoven,  Bor Gonzalez Usach,  Ricardo Ruy Valle-mena, 
 Manuel del Valle,
 David Van Horn, Nick Vaughn,  Simeon Veldstra,  Andre Venter,  Jan Vitek,  Marco Villotta, 
 Mitch Wand, Yuxu (Ewen) Wang,  Michael Wijaya,  G. Clifford Williams,  Ewan Whittaker-Walker,  Julia Wlochowski, 
 Roelof Wobben, J.T. Wright,   Mardin Yadegar,  Huang Yichao,  Yuwang Yin, 
 Andrew Zipperer,  Ari Zvi for comments on drafts of this second edition.</p>

<p>The HTML layout at <span class="stt">htdp.org</span> is the work of Matthew Butterick, who
 created these styles for our on-line documentation.</p>

<p>Finally, we are grateful to Ada Brunstein and Marie Lufkin Lee, our editors
 at MIT Press, who gave us permission to develop this second edition of
 <span style="font-style: italic">How to Design Programs</span> on the web. We also thank MIT’s Christine
 Bridget Savage and John Hoey from Westchester Publishing Services for
 managing the final production process. John Donohue, Jennifer Robertson, and Mark
 Woodworth did a wonderful job of copy editing the manuscript.</p>

<div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="part_prologue.html" title="forward to &quot;Prologue: How to Program&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>