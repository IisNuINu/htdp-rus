<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=0.8"><title>Epilogue: Moving On</title><link rel="stylesheet" type="text/css" href="part_epilogue_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="part_epilogue_files/shared.css" title="default"><link rel="stylesheet" type="text/css" href="part_epilogue_files/racket.css" title="default"><link rel="stylesheet" type="text/css" href="part_epilogue_files/manual-style.css" title="default"><link rel="stylesheet" type="text/css" href="part_epilogue_files/manual-racket.css" title="default"><script type="text/javascript" src="part_epilogue_files/scribble-common.js"></script><script type="text/javascript" src="part_epilogue_files/manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick='TocviewToggle(this,"tocview_0");'>в–ј</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">How to Design Programs, Second Edition</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue:<span class="mywbr"> &nbsp;</span> How to Program</a></td></tr><tr><td align="right">I&nbsp;</td><td><a href="part_one.html" class="tocviewlink" data-pltdoc="x">Fixed Size Data</a></td></tr><tr><td align="right"></td><td><a href="i1-2.html" class="tocviewlink" data-pltdoc="x">Intermezzo 1: Beginning Student Language</a></td></tr><tr><td align="right">II&nbsp;</td><td><a href="part_two.html" class="tocviewlink" data-pltdoc="x">Arbitrarily Large Data</a></td></tr><tr><td align="right"></td><td><a href="i2-3.html" class="tocviewlink" data-pltdoc="x">Intermezzo 2: Quote, Unquote</a></td></tr><tr><td align="right">III&nbsp;</td><td><a href="part_three.html" class="tocviewlink" data-pltdoc="x">Abstraction</a></td></tr><tr><td align="right"></td><td><a href="i3-4.html" class="tocviewlink" data-pltdoc="x">Intermezzo 3: Scope and Abstraction</a></td></tr><tr><td align="right">IV&nbsp;</td><td><a href="part_four.html" class="tocviewlink" data-pltdoc="x">Intertwined Data</a></td></tr><tr><td align="right"></td><td><a href="i4-5.html" class="tocviewlink" data-pltdoc="x">Intermezzo 4: The Nature of Numbers</a></td></tr><tr><td align="right">V&nbsp;</td><td><a href="part_five.html" class="tocviewlink" data-pltdoc="x">Generative Recursion</a></td></tr><tr><td align="right"></td><td><a href="i5-6.html" class="tocviewlink" data-pltdoc="x">Intermezzo 5: The Cost of Computation</a></td></tr><tr><td align="right">VI&nbsp;</td><td><a href="part_six.html" class="tocviewlink" data-pltdoc="x">Accumulators</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Epilogue:<span class="mywbr"> &nbsp;</span> Moving On</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;">вЂў</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Epilogue:<span class="mywbr"> &nbsp;</span> Moving On</a></td></tr></tbody></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.0.0.10</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="part_six.html" title="backward to &quot;VI Accumulators&quot;" data-pltdoc="x">в†ђ prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next в†’</span></span>&nbsp;</div><h3><a name="(part._part~3aepilogue)"></a>Epilogue: Moving On</h3><a name="(part._chap~3apart~3aepilogue)"></a><table cellspacing="0" cellpadding="0"><tbody><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._computing%29" class="toclink" data-pltdoc="x">Вычисления</a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._programming%29" class="toclink" data-pltdoc="x">Разработка программ</a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._moving-on-devs%29" class="toclink" data-pltdoc="x">Вперед, разработчики и компьютерные ученые</a></p>

</td></tr><tr><td>

<p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._moving-on-everyone%29" class="toclink" data-pltdoc="x">Вперед, бухгалтеры, журналисты, хирурги и все остальные </a></p>

</td></tr></tbody></table>

<p>Вы подошли к концу этого введения в вычисления и программирование, или, как мы здесь говорим, 
проектирование программ. Хотя по обоим предметам можно узнать больше, это хороший момент, чтобы 
остановиться, подвести итоги и заглянуть в будущее.</p>

<h4><a name="(part._computing)"></a>Вычисление</h4>

<p>В начальной школе вы научились считать с помощью чисел. Сначала вы использовали 
числа для подсчета обычных вещей: три яблока, пять друзей, двенадцать рогаликов. 
Чуть позже вы столкнулись со сложением, вычитанием, умножением и даже делением; 
затем пришли дроби. В конце концов, вы узнали о переменных и функциях, которые 
ваши учителя назвали  <span style="font-weight: bold">алгеброй</span>. 
Переменные представляют числа, а функции соотносят числа с числами.</p>

<p>Поскольку вы использовали числа на протяжении всего этого процесса, вы не 
слишком много думали о числах как о средстве представления информации о реальном мире. 
Да, вы начали с трех медведей, пяти волков и двенадцати лошадей; но в старшей 
школе никто не напоминал вам об этих отношениях. </p>

<p>Когда вы переходите от математических вычислений к вычислениям, центральным 
становится шаг от информации к данным и обратно. В настоящее время программы 
обрабатывают представления музыки, видео, молекул, химических соединений, 
бизнес-случаев, электрических схем и чертежей. К счастью, вам не нужно кодировать 
всю эту информацию числами или, что еще хуже, просто <span class="RktVal">0</span> и
 <span class="RktVal">1</span>; если бы вам пришлось, жизнь была бы невообразимо утомительной. 
Вместо этого вычисления обобщают арифметику и алгебру, так что, когда вы программируете, 
вы можете кодировать - а ваши программы могут выполнять вычисления - со строками, 
логическими значениями, символами, структурами, списками, функциями и многими 
другими видами данных. 
</p>

<p>Классы данных и их функции имеют эквивалентные законы, объясняющие их значение, 
точно так же, как законы для чисел и их функций. Хотя эти эквивалентные законы так 
же просты, как <span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> 
</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)
</span> вычисляется в <span class="RktVal">2</span> и <span class="RktPn">(</span><span class="RktSym">not</span><span class="stt"> </span><span class="RktVal">#true</span><span class="RktPn">)</span> эквивалентно 
<span class="RktVal">#false</span>, вы можете использовать их для прогнозирования поведения всей программы. 
Когда вы запускаете программу, вы фактически просто применяете одну из ее многочисленных функций, 
действие, которое вы можете объяснить с помощью правила бета-тестирования, впервые упомянутого в 
Intermezzo 1: Beginning Student Language. После того, как переменные заменяются значениями, 
законы данных вступают во владение до тех пор, пока у вас не останется только значение или 
другое применение функции. Но да, это все, что нужно знать о вычислениях. 
</p>

<h4><a name="(part._programming)"></a>Разработка Программы</h4>

<p>Типичный проект разработки программного обеспечения требует сотрудничества многих программистов, 
а результат состоит из тысяч функций. За время существования такого проекта программисты приходят 
и уходят. Следовательно, структура дизайна программ на самом деле является средством коммуникации 
между программистами во времени. Когда вы приближаетесь к коду, который кто-то написал некоторое 
время назад, программа должна выражать свою <a name="(idx._(gentag._764))"></a>цель и свои отношения 
с другими частями - потому что этого другого человека может больше не быть. 
</p>

<p>В таком динамичном контексте программисты должны создавать программы 
дисциплинированно, если они хотят работать разумное количество часов или 
производить высококачественные продукты. Следование методу систематического 
проектирования гарантирует, что программная организация будет понятна. 
Другие могут легко понять части и целое, а затем исправить ошибки или 
добавить новые функциональные возможности. 
</p>

<p><a name="(idx._(gentag._765))"></a>Процесс проектирования, описанный в этой книге, 
является одним из этих методов, и вы должны следовать ему всякий раз, когда вы 
создаете программы, которые могут вас заинтересовать. Вы начинаете с анализа мира информации 
и описания данных, которые представляют информацию. Затем вы составляете план, 
рабочий список необходимых функций. Если этот список велик, вы итеративно уточняете процесс. 
Вы начинаете с подмножества функций, которые быстро создают продукт, с которым клиент 
может взаимодействовать. Наблюдая за этими взаимодействиями, вы быстро поймете, 
какими элементами вашего рабочего списка заняться дальше. </p>

<p>Разработка программы или только функции требует строгого понимания того, 
что она вычисляет. Если вы не сможете описать назначение фрагмента кода кратким объявлением, 
вы не сможете создать ничего полезного для будущих программистов. Придумайте и проработайте 
примеры. Превратите эти примеры<a name="(idx._(gentag._766))"></a> в набор тестов. 
Этот набор тестов еще более важен, когда речь идет о будущих модификациях программы. 
Любой, кто изменяет код, может повторно запустить эти тесты и подтвердить, что программа 
по-прежнему работает для базовых примеров. </p>

<p>В конце концов ваша программа также потерпит неудачу. Другие программисты 
могут использовать её непредвиденным образом. Реальные пользователи могут обнаружить 
различия между ожидаемым и фактическим поведением. Поскольку вы разработали код систематически, 
вы будете знать, что делать. Вы сформулируете тестовый пример неудачи для основной функции 
вашей программы. Из этого теста вы получите тестовый пример для каждой функции, упоминаемой 
в основной функции. Те функции, которые проходят свои новые тесты, не способствуют отказу. 
Одна из других делает ошибку; иногда некоторые могут вступить в сговор, чтобы создать ошибку. 
Если неработающая функция объединяет другие, возобновите создание теста; в противном случае 
вы нашли источник проблемы. Вы узнаете, что устранили проблему, когда программа в целом пройдет 
все тесты.</p>

<p>Независимо от того, насколько усердно вы работаете, функция или программа 
не выполняются с первого раза, когда проходят набор тестов. Вы должны найти время, 
чтобы осмотреть её на предмет дефектов дизайна и повторений дизайна. Если вы обнаружите 
какие-либо шаблоны проектирования, создайте новые абстракции или используйте существующие 
абстракции для устранения этих шаблонов.</p>

<p>Если вы будете соблюдать эти правила, вы создадите надежное программное 
обеспечение с разумными усилиями. Оно будет работать, потому что вы понимаете, 
почему и как оно работает. Другие, кто должен изменить или улучшить ваше 
программное обеспечение, быстро поймут его, потому что код сообщает о его 
процессе и его назначении. Работа над этой книгой помогла вам начать. 
Теперь вы должны практиковаться, практиковаться, практиковаться. И вам придется 
узнать о проектировании программ и вычислениях гораздо больше, чем может 
научить первая книга. </p>

<h4><a name="(part._moving-on-devs)"></a>Вперед, разработчики и компьютерные ученые </h4>

<p>Прямо сейчас вам может быть интересно, что изучать дальше. Ответ - 
больше программирования и больше вычислений.</p>

<p>Как студенту, изучающему разработку программ, вашей следующей задачей будет - узнать, 
как процесс проектирования применяется в условиях полноценного языка программирования. 
Некоторые из этих языков похожи на языки обучения, и переход на них будет легким. 
Другие требуют другого мышления, потому что они предлагают средства для формулирования 
<a name="(idx._(gentag._767))"></a>определений данных (<span style="font-style: italic">классов</span>
 и <span style="font-style: italic">объектов</span>) и для <a name="(idx._(gentag._768))"></a>
формулирования сигнатур, чтобы они перекрестно проверялись перед запуском программы 
(<span style="font-style: italic">типы</span>). 
<span class="refelem"><span class="refcolumn"><span class="refcontent">С учетом ваших знаний 
это легко для вас. выучить <span style="font-style: italic">Racket</span>, язык, лежащий в 
основе языков обучения в этой книге. См. <a href="http://realmofracket.com/about.html"><span style="font-style: italic">
Realm of Racket</span></a> для возможного введения. Кроме того, вам также нужно будет узнать, 
как масштабировать процесс проектирования для использования и производства так называемых 
фреймворков («стеков») и компонентов. Грубо говоря, фреймворки абстрактные элементы функциональности, 
например, графический пользовательский интерфейс, подключения к базам данных и веб-подключения, 
которые являются общими для многих программных систем. Вам нужно научиться создавать экземпляры 
этих абстракций, и ваши программы будут составлять эти экземпляры для создания согласованных систем. 
Точно так же обучение созданию новых компонентов системы также является неотъемлемой частью повышения 
ваших навыков. </p>

<p>Будучи студентом факультета вычислительной техники, вам также придется расширить 
свое понимание вычислительного процесса. В этой книге основное внимание уделяется законам, 
описывающим сам процесс. Чтобы действовать как настоящий инженер-программист, вам 
необходимо знать, сколько стоит процесс, как на теоретическом, так и на практическом уровне. 
Более глубокое изучение концепции большого О(big-O) - это первый маленький шаг в этом направлении; 
научиться измерять и анализировать производительность программы - вот настоящая цель, 
потому что вам, как разработчику, понадобится этот навык на регулярной основе. 
Помимо этих основных идей, вам также потребуются знания об аппаратном обеспечении, 
сетях, многоуровневом программном обеспечении и специализированных алгоритмах в 
различных дисциплинах. </p>

<h4><a name="(part._moving-on-everyone)"></a>Вперед, бухгалтеры, журналисты, хирурги и все остальные</h4>

<p>Некоторые из вас хотели узнать, что такое вычисления и программирование. 
Теперь вы знаете, что вычисления - это просто обобщение вычислений, и вы 
можете почувствовать, насколько полезна для вас разработка программ. 
Даже если вы больше никогда не будете разрабатывать программы, вы знаете, 
что отличает гаражного программиста от серьезного разработчика программного 
обеспечения. Когда вы взаимодействуете с разработчиками как профессионал, 
вы знаете, что систематический дизайн имеет значение, потому что он влияет на 
качество вашей жизни и прибыль вашего бизнеса. </p>

<p>В действительности, однако, вы, вероятно, снова будете «программировать» 
на регулярной основе; вы можете просто не увидеть свою деятельность в этом свете. 
Представьте на мгновение журналиста. Его история начинается со сбора информации и данных, 
их размещения, систематизации и добавления анекдотов. Если вы приглядитесь, то увидите, 
что это только первый шаг<a name="(idx._(gentag._769))"></a> процесса проектирования. 
Обратимся к семейному врачу, который, проверив ваши симптомы, сформулирует гипотезу о том, 
что может на вас повлиять. 
Вы видите шаг два? Или представьте себе юриста, который иллюстрирует суть спора рядом 
примеров - пример третьего шага. Наконец, инженер-строитель перекрестно проверяет мост, 
когда он построен, чтобы убедиться, что он соответствует плану и лежащим в его основе 
статическим расчетам. Перекрестная проверка - это форма тестирования - шестой шаг процесса; 
он сравнивает фактические измерения с ожидаемыми значениями прогнозных расчетов. 
Каждый из этих профессионалов разрабатывает систему для эффективной и результативной работы; 
и в глубине души эта система, вероятно, будет напоминать процесс проектирования, 
использованный в этой книге. </p>

<p>Теперь, когда вы примете, что многие действия являются формой программирования, 
вы можете перенести дополнительные идеи из процесса проектирования в свою собственную жизнь. 
Например, если вы распознаете шаблоны, вам может потребоваться немного дополнительного времени, 
чтобы создать «абстракцию» - единую точку управления - чтобы упростить вашу будущую работу. 
Итак, независимо от того, станете ли вы бухгалтером, врачом или кем-то еще, помните о 
процессах проектирования, куда бы вы ни пошли и чем бы вы ни занимались. </p>

<p><span style="font-weight: bold">Упражнение</span> Напишите небольшое эссе о том, как 
<a name="(idx._(gentag._770))"></a>процесс проектирования может помочь вам в выбранной вами профессии. 
<a href="part_six.html#%28counter._%28exercise._ex~3abezier%29%29" class="ex-end" data-pltdoc="x"></a></p>

<div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="part_six.html" title="backward to &quot;VI Accumulators&quot;" data-pltdoc="x">в†ђ prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next в†’</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>